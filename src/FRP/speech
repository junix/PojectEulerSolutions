Strangeloop 2014.

"Controlling Time and Space: Understanding the Many Formulations
of FRP"

Presenter: Evan Czaplicki.

Live Captioning by Norma Miller, whitecoatcaptioning.com

EVAN CZAPLICKI: OK, can you hear me OK?

>> Cool.  OK, so I'm going to get started.  I'm Evan Czaplicki.
Over the course of thinking about function reactive programming,
I've learned some things, so this talk is really distilling those
years into like a 40-minute thing so you don't have to go through
the same thing that I did.  And I went with controlling time and
space, because at the time I was feeling like some kind of time
Lord with like time travel and but the real focus is understanding
what FRP is, and there's actually quite a lot of diversity about
what that term actually means so diving into that and sort of being
able to pick that apart.  So our goals today are to understand what
is FRP, how do we categorize different things that fall into that
umbrella and then how do we evaluate those things in a nice way?
So the way we're going to get started, learning these things is
start with sort of what I'm calling first-order FRF and this is
kind of what Elm looks like and then we'll branch out into a bunch
of different variations that sort of build on core.  So first thing
is first-order FRP.  Another way to think about that is how it works
in Elm.  We'll see why it's first order in just a bit.  When we're
dealing with FRP, what we really want is a way to deal with interaction
with the world.  So we have a user over here and they're typing and
they're looking at things, so we're getting key presses, mouse
events and bringing that into some sort of processing system, so
in Elm, this is called a signal graph.  In Javascript it might be
a thing with callbacks.  So rather than using callbacks in these
ad hock ways of structuring times, we actually have system that
gives a structure that we can evaluate.  So we get this core of
signal graphs.  >> So the key part of a signal graph is that it has
inputs from the world.  So these are things like mouse.position and
if you look at the type of this, that means has typed, and it's not
just a pair of integers, but it's a signal of a pair of integers.
So as you move your mouse, that value is updating.  Another example
of this is keyboard.last pressed and you can think of this the same
way.  Time is passing and we're seeing the value change over time.
So in this case, I was typing hello Strangeloop, and then I got
distracted and then I surfed the web for a bit and I came back at
a later point so you're seeing this change over time and having a
way to talk about that explicitly.  >> So from inputs, we can do a
little bit of -- that's sort of like the raw information coming
from the world but on top of that we want to be able to transform
those things, so with for that we use this function lift.  So let's
-- we take in a signal, so we can take in our key presses signal
and then we have a function that goes from As to Bs.  So we take
the values of A and we go make a signal of B.  So example of this
would be saying, we have this function is consonant, so we're
checking each of these letters, and what we get out is a new signal,
so we say, OK, H, that's a consonant, E, that's not, L, L, so on
and so on.  So we can actually transform these values as they change
over time.  So what we're doing is really handling a time-bearing
thing rather than do an event based callback system.  The next thing
we can deal with is state.  So in Elm, this is called fold p.  You
can read this from fold from the past.  And what's going on here
is let's take our trusty key presses signal, and when we actually
fold P we're going to give it a starting state, this is this guy,
and a way to update that state.  So whenever a key press comes in,
I'm going to say, cool, I got the key, I got the state that I'm
working with and I'm going to increment that by 1, so when we look
at the signal that we get out, we count, 1, 2, 3, so on and so
forth.  So this is a very simple example of carrying state but you
can think of something quite a bit more complicated where perhaps
you have a to do list application and you want to model what your
program is doing as things change over time.  >> Finally, we have
a way to merge signals together, so the very basic one is called
merge which it takes two signals and it just kind of merges them
together.  This is one of the well-named primitives.  [laughter]
>> There's another one called lift 2, questionably named primitive.
This takes two signals and it takes the functions from both of them
and produces a signal.  So this is to say if I have a signal of X
coordinate and Y coordinate, I can can apply a signal that puts
them together.  And so in addition to lift 2, there's lift lots of
them.  It stops at 8.  But you can go higher through various tricks.
So what we have is a way of talking about this graph, setting up
an input from the world, transforming it, updating some state,
merging things together and this gives us the tools to build this
signal graph.  And so if you imagine a program like a to-do list,
like this, you can think of this program as we model the inputs,
we go update some state, we transform that into something to show
on screen, and sort of we have this architecture for application.

>> So that's sort of the operational details, that's kind of what
you would learn, the very abbreviated version of what you would
learn if you dug into Elm, but it doesn't really get at these
principles that went into that design so when you think about the
core design you start to see some details that aren't apparent
immediately.  The first one is that signals are connected to the
world.  This is a key property of Elm system that doesn't appear
everywhere else, but you have direct connection to mouse position
or keyboard.  Signals are infinite.  This one is subtle but it
essentially means that there's no such thing as deleting a signal.
There's no -- you can't have an input that you then later throw
away.  This is like saying I have the mouse, but then I took the
mouse off of my laptop, like it doesn't -- like the -- essentially
it's saying the inputs to your program are fixed.  >> Another
property is signal graphs are static.  There's a known structure
for your application from startup all the way into the future and
this sounds like, oh, it dynamic.  We'll get to that.  There are
tons of tradeoffs that get to that.  So this is actually a property
that gives you lots and lots of power that we'll get into in a bit.
Finally it's synchronous to a fault.  What that means is when you
type hello, as someone who's observing, you want them to you need
to be sure that those events flow through and maintain order so in
Elm that's maintained by default.  That property isn't shared by
all variations.  >> So OK, what do we get?  What do we get when we
make these design choices?  So the first one is efficiency.  This
one, it doesn't -- it's not clear at this point why I'm saying this,
but eventually what's happening is everything is event-driven,
right?  Event comes to world, it flows through our graph, it may
get sent back as an enter state.  So we'll see why it's necessary
to point out that efficiency is a property that we have.  >> Another
thing is architecture.  So this is a Elm program that's kind of
like the typical example of a MVC-style application.  And this is
just hooking up to the world, and so you can see it's actually using
local storage, so if I reload this page, the changes propagate over,
because I'm saving it, so which is to say, interacting with the
world becomes quite simple.  Now, when we look at the structure of
this application, it breaks up nicely into four parts.  As of every
Elm program will.  It breaks up into a model.  That's tiny.  Is
that better-ish?  OK, we just want to overview here, we don't need
to see the details exactly so we first have a model, saying here's
the state of my application.  I have a list of tasks.  What is the
task.  What I'm editing.  So we're explicitly modeling what our
application means and from there we have update, how do I take that
state and step it forward based on stuff people want to do, so maybe
we want to add a task or delete a task and finally we have a view,
which is how do I take the state of my application and turn it into
HTML that I can show on the screen and what's nice here is we can
make sort of reusable function, so I can say how do I show a task
on screen and then I can say map for that over all of my visible
tasks so I can start to build up UI in a really nice declarative
way with these pure functions.  So that architecture, that structure,
comes from the static signal graphs, they guide you towards writing
your applications that way.  I consider that a really big benefit.
Another thing that you get is hot swapping so you guys may have
seen the Mario program from last year.  If you didn't, it's a good
way to learn Elm in like that isn't only like 10 minutes.  So notice
I walked him over to the side of the screen, and I'm going to change
gravity a little bit, and now jump him and then change it again,
and suddenly gravity is stronger, so we're able to change the
behavior of the program while the program is running, and sort of
see those changes propagate automatically.  >> So the final thing
that we get -- well, not the final thing, but like the other thing
I felt necessary to share with you guys today, is the time travel
debugger, so you may have seen this online, but we've got a new
version coming out that's easy to install and so I just wanted to
do a tiny demo of that.  >> So here's that trusty Mario program.
And we've got like mega Mario.  Aww, man, I changed the code by
accident last night, I forgot to change it back.  But we can see
where mega Mario was before and we can pause this program and sort
of go back in time to wherever we want to go, so say we go like
near the beginning and we pick up where we started there.  So we
say OK, I didn't want it to walk to the left, I wanted to walk to
the right.  So one cool thing here is we can look at data in our
program, so if I zoom, if I go back a little bit, you can see the
arrows value, I'm now pressing right and if I go back a little more
I'm pressing up right now and then I stop pressing up, so you can
start to get really cool insights as to what's going on in your
program at particular points in time and what's neat about this,
you can, oh, yeah, there's another thing that's neat about it that
I forgot to tell you.  >> [laughter] >> OK, so you see I'm jumping
around.  OK, so here's the code, again it's got model, display,
these parts.  And I want to change, I want to change gravity again
so when I save that and this is in sublime text, those changes
propagate but they propagate for the whole history so we can see
that Mario can jump way too high and we're like that's no good, we
want to see that Mario has a reasonable kind of jump.  So now we've
got super Mario who jumps.  >> OK.  >> [applause].  >> So these are
kind of like the core things that come from having a static signal
graph.  A lot of these abilities to swap in code and replay code
comes from the fact that if we know what the program looks like at
the start we know what it's going to look like in an hour, in a day
and we don't have to do some kind of crazy complex analysis to
figure that out or to match things out.  So that's the sot of an
overview of what first-order FRP is like, but the question you may
have in the back of your head, you know, what happens if signal
graphs could be reconfigured?  What is higher order FRP?  Surely
higher is better.  So this is the question that sort of guides a
lot of thinking on FRP and a lot of the research because it's a
very, very surprisingly hard question.  So there are a couple ways
that it has been pursued, we're going to explore them one by one
and they sort of fall into nice separate categories.  So let's dive
in.  The first one is higher order FRP, so this is just saying OK,
we took this core design and we don't like that signal graphs are
static.  We want to get rid of that constraint, so what do we need
to add?  What do we lose?  One thing I should point out is that
with all of these variations it's not better or worse, it's trades,
right?  Whenever you're making a decision, it's like I'm going to
get this feature and I'm going to lose this other one.  So what
happens when we get rid of this core design that signal graphs are
static?  So typically this is with a function called join.  So not
super clear exactly what that might mean, but here we have a signal
of signals.  Again it's not super clear what that might mean, but
you can think of it as, I have a group of signals and I'm picking
which one to listen to right now, so you can think of this signal
as the guy coming out here and this signal as like choosing one of
these, so as I get updates, I listen to a different signal coming
in.  >> So that seems straightforward, right?  It sounds plausible?
>> So already at this point we have some questions, so what happens
to these signals that aren't in use right now?  Right?  No one's
listening, so should it keep running?  Should it pause?  >> This
is a surprisingly difficult question.  Now you get into even crazier
issues when you start adding signals that hadn't previously been
observed and you can keep adding these and adding these.  So to
make this a bit more concrete, let's use another example where we
see the bad behavior here so here we have a very simple signal.
It's counting mouse clicks.  And let's see something a bit more
complicated.  So here we've got something that's either counting
mouse clicks or it's zero.  So if I put true in I'm going to get
count mouse clicks, if I put mouse in, I'm going to get a constant
signal of 0.  So let's say we start with true and I click 5 times,
so I should be at 5.  Now I go false it's 0, and I click 5 more
times and I go true again.  OK, what should the value be of my
signal?  Should it be 0 because I'm restarting?  Should it be 5
because I'm picking up where I left off?  Should it be 10 because
that's the total number of clicks that have happened over the total
of the course of this application?  Now, because of a lot of this
research happens in purely functional languages or languages where
we want to have properties about equational reasoning, our answer
is chosen for us, so if you look at this code, count mouse clicks
and this code, count mouse clicks, they're the same expression, so
it should be possible to replace this variable with click count and
have this same behavior.  So essentially our behavior is chosen for
us.  When we get to that point where we go true again, it needs to
be at 10, it needs to be the count of the full number of clicks.
>> So where this starts to get crazy is let's say no one defined
that, but they wrote this program.  >> So I start my program, this
signal is false.  So it's 0000, I wait 10 minutes, I wait 20 minutes
I'm clicking away like a maniac and suddenly I change to count mouse
clicks, this is a signal it's never seen before but I know that it
needs to keep track of all of those past clicks.  So I'm in a place
that I don't necessarily know that I'm going to need that signal.
I know that I need to know that past history.  I may need to look
at all the past events to be able to reconstruct the signal so that
I have all this history.  Another way to think of this is memory
is linear in time.  I need to keep track of that in case you have
to look back.  The solution isn't that this is a bad idea, it's
that we only should switch to signals that have safe amounts of
history.  It's not that switching is necessarily bad, but that
particular kind of switching definitely causes problems.  >> So
what this has turned into is how do we restrict the definition of
join with fancier type?  How do we write a way to switch between
things that rules out the possibility of this infinite look-back
so we can implement it efficiently and this is where a lot of the
research has gone on this topic and when you see a modern library
in Haskell or wherever else, that is in this category of higher
order FRP it's going to be doing a trick like this, so one cool
example of it is this paper higher order functional reactive
programming in bounded space.  The names get really long for these
papers when your topic is functional reactive programming.  He uses
a thing called linear types and this is a thing that doesn't appear
in Haskell or OCaml.  The point is that this is rare type system
to see.  >> So we can write programs like this, but we're making
some tradeoffs, so we got rid of the idea that signal graphs are
static, so we're losing the hot spot thing is really easy.  We're
losing that time travel debugging is straightforward, we're losing
that architecture is really straightforward and we may be dealing
with a slightly more complex API or a more complex type system, so
when thinking about this one, let's say there weren't any tradeoffs
here.  Let's say this was like the -- the problems were solved.
Let's look back at the architecture of this to do MBC thing from
before.  So when I look at this code and lets let's say I could
switch on signals, would I want to architect my application that
way?  Given the ability, would I use it?  So maybe that would mean
that instead of a state that I model like this, it has the tasks
isn't just a list of tasks, it's a list of signals of tasks, and
we're doing some more complicated signal structure with that, and
I'm not sure that's a better way.  I think that's something that
I'd like to see some examples and that could be -- that could be
quite interesting, but I'm not -- I'm not totally sold yet.  So
next we have a think called asynchronous data flow, so if you know
reactive extensions, reactive cocoa, bacon js, essentially if you
see something look that looks like FRP and it is an imperative
language it's probably in this category of things.  So again we can
look at our core design and see which things we cross off because
of course we cross off that signal graphs are static, because we
don't want that.  Signals are infinite, so this is another way of
saying that signals can end, like I can start it up, it can trigger
four events and then it can die.  Finally we get rid of the design
that it's synchronous by default.  This doesn't mean you can't have
synchrony, but you have to do it by yourself, that's asynchronous
is a hint that that's one thing we're getting rid of.  So these
guys use something called flatten.  It may look very familiar.  When
you're writing in imperative language, you get this extra ability
of naming things in a way that is clear for people.  So flattening
signals the signals, it's quite intuitive to name it that way.  So
but this is the same idea, and it ends up looking a little bit
different because we've given up on more of these core design points.
I shouldn't say given up.  We've decided to shoot for a different
point in the design space.  So if we look back at that program from
before, where we were like OK, count mouse click needs to be equal
to count mouse clicks, we get all these problems, OK, now we're in
an imperative language and no one ever said you were going to have
this guarantee.  So whenever you're creating these signals you're
creating a completely new one.  That means I start with true, I
count 1, 2, p, 4, 5, I go to false so it's zero and I switch to
true.  I start at 0 again, it's an entirely new signal.  So we're
creating new things and there's some mechanism of cleaning up garbage
as we go.  We still have that question from before of what happens
when no one's listening to a signal, right?  You may have created
a signal and no one's paying attention.  So some variations of this
style have a thing called hot and cold signal, so reactive extensions
in particular has hot and cold signals, meaning if I have a signal
and no one's listening, there's a joke here.  If I have a signal
and no one's listening, what should happen and if it's hot, it's
going to keep produce things and if it's cold it's going to stop.
>> OK.  So finally we have arrowized FRP so this is something you
can see in Haskell.  Yampa is the first one that came out, net wire
is I think a more modern version that looks more interesting.  Elm
has a thing called automaton which is the same concept.  We cross
off that signal graphs are static.  Now in this one we cross off
that signals are connected to the world.  This is a very clever and
interesting choice that has some cool effects.  So we'll get into
this by looking at who how this library works in Elm, so for the
basic API, we've got this function called pure.  And this is creating
an automaton so you can think of an automaton as a little robot who
takes things in and gives things on the other side.  So I can think
of an automaton of increments by 1.  You give 1, it gives you 2,
you give it 42, it gives you 43, you give it 100, it gives you 101.
Here is how you write that out.  You have a function, it takes in
input and it increments it by 1.  Next we have a made to model
state, so this is quite like a full P.  This one is nicer to see
by example.  So here I have my base value so in my brain I have 0,
and then as my step function, whenever I get in a value, I'm going
to say cool, that's a nice value you gave me and I'm going to take
my total and increment it by 1, so someone gives me the spring hello
and I say oh, I got a 1, and I give out 1 and someone says how are
you?  OK, I got 2, I got 2 messages so here we can model state in
the same way.  The last thing I want to show is how we chain these
together.  So when you have two little automatons that are processing
information you can put them next to each other.  So you can say I
have one guys that takes As and gives Bs, and one guy who takes Bs
and gives Cs, and you put them together.  Chain.  1, 2, 3, and
process that information.  >> So this gets interesting when you
want to start switching on things.  So you can think of each of
these as a little automaton who has some state, and this these are
all counting, so their state starts at 0.  And we're going to put
them into our sort of active position.  So values will be flowing
through here, so if we start out, we know this guy is 0 and then
we pass a couple events through, let's say 5 events went through,
so increments 1, 2, 3, 45, and we switch it out for the green one.
Now, this guy is holding 5, this guy is holding 0, this guy is
holding 0.  What's clever here is these nodes aren't connected to
the world.  So when we take it out of the graph, this part of what
happens, does it keep running, it's answered, it doesn't keep
running, it's not connected to anything and what this means is we
can switch things in a more creative way.  So let's say I give this
three events, 1, 2, 3, and then I switch again, so now I've got 5
in here, 3 in here, 0 and we can switch this in really interesting
ways.  So this is kind of the key insight of arrowized FRP, but we
gave up something really important which is that we can talk about
signals coming from the world.  So in this system, there's no way
to talk about mouse position.  That's something that exists externally.
So what that means is, arrowized FRP is really about structuring
code and so it can show up in a library for Elm or Haskell or
whatever, and it's in competition with like using pure functions
and modules as a means of abstraction.  So the question to ask
yourself here is, for my particular domain, is this way of structuring
code giving me benefits?  And I know there's been success with music
and with net wire, there may be some other cool things of structuring
your code, I personally haven't used it a lot, but it's compatible
with all of these different approaches.  >> So when we zoom out,
you notice I put the circle around Elm to have all three colors,
indicating that this isn't a competition of like which one is better,
but rather, different points in a design space that are complementary.
So when we think of how this connects to Elm, how does higher order
FRP connect?  I mean this is really adding a feature.  This is
something that could be done.  I personally don't want to take that
step and give up these the properties that Elm is able to get.  If
we find a way to do it that's nice, that's totally possible to add
to Elm.  With asynchronous data flow here you're giving up the
synchrony guarantee, so there isn't something you'd embed in Elm,
it's something he'd embed Elm in.  So let's say you're Prezi who
employs me you'd like to make a little part of application.  What
you can do is hook up to Elm and hook up with and have that
interactivity so you can have all these nice guarantees when you
want but still integrate with a system that has something more
complex going on.  Finally arrowized FRP, it can just be pa library.
It is a library.  And so when we think of the broad categories here,
we can think of one as static graphs, graphs that don't change over
time, and other categories as dynamic graphs, graphs that do change
over time, the sort of broad connecting categories, and then for
distinguishing these bottom 3, you can look, are there infinite
signals?  Another way to tell is is it in Haskell, it's probably
in this category.  Finite event streams, so this is signals that
can end.  An easier way to tell is like is it an imperative language
and finally neither.  In this world we don't talk about signals,
whether they're finite or infinite or not.  So this kind of gives
us our taxonomy or like different points in the design space, so
let's sort of pick out the lessons we can from learn from this.  I
know I introduced parts of Elm really quickly.  I didn't do a lot
of examples.  You request learn more at this site about Elm in
particular.  If you want to learn more about the history of FRP,
specifically first-order FRP and higher order FRP, this is my thesis
and it has a section on history of FRP and if you look at the
citations, you'll just see links to all the papers that have been
published by that -- by the time this was written.  >> When it comes
to categorizing things, the -- it means I'm running low on time.
When it comes to categorizing, the questions you want to be asking
are, is it synchronous by default?  Right, am I getting these
ordering guarantees where I know if someone types hello and clicks
a button that we're going to get it in that order and not the button
click happens halfway through because the processing takes too long
or something.  Does it Ali asynchrony?  It's not just that you want
asynchrony.  But there are times you want to block everything.  You
ever need to make writes to disc and so Elm builds in this idea of
asynchrony in a nice way.  And not all systems that are out there
have a plan for how asynchrony will work, so that's something that
you should keep in mind, especially when you're looking at higher
order FRP, can I talk about inputs?  So this is essentially a way
of saying like, is it a arrowized system, is it a way of structuring
code or is it a way of talking about events?  Can I reconfigure my
graph?  And when you want to evaluate this, the question isn't how
can I get the fanciest like words on my library, it's what properties
do I need for my application, right?  So when you are a owe looking
at something like reactive extensions and you want to write some
server code, where I've got ten people connecting to my server,
they have all want some information, there asynchronous by default
is great, why should any of them block depending on the order they
came in.  Or if you're dealing with some system where it's not that
important to have this synchronating.  That will fit you really
well.  If you want to have the kind of debugging tools that Elm
has, you may want to make a different choice, yeah, what is debugging
like?  This is a question I can't answer for the sort of dynamic
graph ones as easily, but it's something to think about when you're
starting out.  Like this isn't just a cool thing to start with, you
have to carry this through for the whole life of your application
and finally, does the code come out nice?  So there may be something
where you like it, and then once you write a lot of code, things
start to feel more complicated than you thought, right?  So this
is particularly important when you're talking about the asynchronous
data flow kind of things.  You can get more features but you're
paying a complexity cost for that and do you need that in your
application?  Is it something that you can live without to get some
more simplicity.  >> If you're interested in learning more about
FRP, if you learn Elm, then it's easy to go to to these other ones
and you learn these principles which you can learn there.  But yeah,
so hopefully this has given you some insight.  Thank you very much.
>> So we've got some time for questions, I think?  Yeah?  AUDIENCE
MEMBER:  [inaudible] >> Yeah, so that's the switch of going to the
sort of asynchronous data post dial.  Oh, so the question was, why
with the joint order in higher order FRP, why keep that constraint
that count mouse clicks goes to.  I can't say for sure if there are
libraries that do that.  This is a design choice you can make, you
get different tradeoffs doing that kind of thing.  That would be
more in the ballpark of the sort of reactive extensions bacon js
style, though.  >> Any other?  >> AUDIENCE MEMBER: (inaudible) >>
>> Yeah, so the question is, like when do you hook up an arrowized
FRP system and what happens once you do hook it up?  So typically
you'll define your arrowized FRP system and design that dynamism
into it and then hook it up and those things will be switched in
and out.  When it's hooked up isn't such a huge deal, in that you
can give it values at any time, and it will step forward of its
sort of world so I'm she not sure if this is answering your question
very well, but yeah, so when you step an automaton forward, what
you're getting is here's the value I started with.  >> Yes?  >>
AUDIENCE MEMBER:  [inaudible] >> Right, so the question is about
how do you get a kind of mod later in an application like a to-do
list; is that fair?  >> AUDIENCE MEMBER:  Yes.  >> So I think that
there are a couple of ways, right, so one is to use the higher order
style, something like ore to give you that configuration.  You can
wrap it in that way.  My opinion is that this is something we should
explore more in Elm.  What I'm advocating right now is sticking
with module system and function, so if you want to modulize your
tasks, you'd make a module that is all about tasks.  What's the
model of them, how do I update it, how do I view them.  And I can
keep doing this sort of nesting architecture to get that kind of
modularity.  And it's not clear to me that one way is going to be
superior to the other and I think there hasn't been enough exploration
to know like this is the right way or even if there is a right way
for all cases.  Yes?  AUDIENCE MEMBER:  [inaudible] >> OK, I'll
take a look.  Yeah, I haven't seen it.  I haven't seen it.  >> >>
Yeah, so that is terminology that I think is a bit confusing, so
we talked, oh, sorry, the question is, how does push versus pull
fit in this taxonomy.  So with the asynchronous data put we talked
about hot and cold.  With Elm it's event driven so meaning it's
push, you push an event to it and that propagates it through.  What
pull means is someone at the bottom says hey, I want to say something
and so that goes through your graph and pulls values sampling from
whatever that time period is.  The argument that we've made in the
work that we've done in FRP is that a push system can model a pull
one in that when you get to the bottom of your program, one way to
say it is I pulled the values through.  Another way to say it is I
trigger a push through and so I don't think there's as huge a
difference between this as -- the distinction isn't as important
as it sounds.  AUDIENCE MEMBER:  [inaudible] >> Say it again?  OK,
so the question is about how do you deal with sort of like too much
data to process through your graph, right, is there a way to drop
things or -- so in the domain of UI, you're dealing with human input
so you're not going to be getting in that situation very often, so
a lot of these systems are prioritized towards use cases like that,
and so I think -- so essentially the subtext here is like what is
the like push-back like mechanism.  I think -- I'm not an expert
on this particular question.  There may be FRP system that do it.
Elm is primarily concerned with UI so it's not the major focus.
I've gone over time a little bit.  Let's chat outside if you have
questions.  Thank you very much.  [break]
